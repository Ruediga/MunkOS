#include <stdint.h>

#include "interrupt/idt.h"
#include "interrupt/exception.h"
#include "std/kprintf.h"

/*
 * Interrupt types
 * ===============
 * -) Exception:
 *      generated by the CPU, includes faults, ...
 * -) Interrupt Request (IRQ)
 *      hardware signal:
 *      1. PIC receives request
 *      2. PIC passes interrupt to cpu
 *      sti / cli works on this type of interrupt only!
 * -) Software interrupts (int):
 *      used to implement syscalls
 * 
 * When interrupt is received, save internal state
 * Then, call Interrupt Service Routine (ISR) (these need to be
 * returned via the iret instruction!) mapped in the
 * Interrupt Descriptor Table (IDT) (which is pointed to by IDTR)
 * Associated number (0 - 255): identify device and cause
 * 
 *  typedef struct {
 *      uint16_t    isr_low;      // The lower 16 bits of the ISR's address
 *	    uint16_t    kernel_cs;    // The GDT segment selector that the CPU will load into CS before calling the ISR
 *	    uint8_t	    ist;          // The IST in the TSS that the CPU will load into RSP; set to zero for now
 *	    uint8_t     attributes;   // Type and attributes; see the IDT page
 *	    uint16_t    isr_mid;      // The higher 16 bits of the lower 32 bits of the ISR's address
 *	    uint32_t    isr_high;     // The higher 32 bits of the ISR's address
 *	    uint32_t    reserved;     // Set to zero
 *  } __attribute__((packed)) idt_entry_t;
*/

typedef struct __attribute__((packed)) {
    uint16_t offset_low;
    uint16_t selector;
    uint8_t ist;
    uint8_t type_attributes;
    uint16_t offset_mid;
    uint32_t offset_high;
    uint32_t reserved;
} idt_descriptor;

struct {
    uint16_t size;
    uint64_t idt_offset;
} __attribute__((packed)) idtr;

// global idt
extern uint64_t isr_stub_table[];
__attribute__((aligned(16))) idt_descriptor idt[256];

void idt_set_descriptor(uint8_t vector, uint64_t isr, uint8_t flags) {
    idt_descriptor *descriptor = &idt[vector];
 
    descriptor->offset_low = isr & 0xFFFF;
    descriptor->selector = 0x08; // kernel offset, change? [TODO]
    descriptor->ist = 0;
    descriptor->type_attributes = flags;
    descriptor->offset_mid = (isr >> 16) & 0xFFFF;
    descriptor->offset_high = (isr >> 32) & 0xFFFFFFFF;
    descriptor->reserved = 0;
}

void initIDT(void)
{
    // fill idt
    for (uint64_t vector = 0; vector <= 255; vector++) {
        idt_set_descriptor(vector, isr_stub_table[vector], 0x8E);
    }
    
    idtr.idt_offset = (uint64_t)idt;
    // max descriptors - 1
    idtr.size = (uint16_t)sizeof(idt) - 1;

    asm volatile (
        "lidt %0\n"
        : : "m"(idtr) : "memory"
    );
}